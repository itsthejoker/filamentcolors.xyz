{% load django_htmx plausible static %}

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="{% static 'vendored/js/htmx.min.js' %}?v=1.9.9"></script>
<script src="{% static 'vendored/js/idiomorph-ext.min.js' %}"></script>
{% django_htmx_script %}
<link rel="stylesheet" href="{% static 'vendored/css/baguetteBox.min.css' %}">
<link rel="stylesheet" href="{% static 'vendored/css/toastify.css' %}">
<link rel="stylesheet" href="{% static 'vendored/icomoon/style.css' %}?v=2">
<link rel="stylesheet" href="{% static 'vendored/css/bootstrap.min.css' %}">
<link rel="stylesheet" href="{% static 'css/main.css' %}?v=14">
<link rel="stylesheet" href="{% static 'vendored/css/material_icons.css' %}">

<style>
    @font-face {
        font-family: "Roboto";
        src: url("{% static 'vendored/Roboto-Regular.ttf' %}") format("truetype");
    }
</style>

{% if not request.user.is_staff or not 'opengraph' in request.path %}
  {% plausible script='script.outbound-links.js' %}
{% endif %}

<script src="{% static 'vendored/js/jquery-3.4.1.min.js' %}"></script>
<script src="{% static 'vendored/js/baguetteBox.min.js' %}"></script>
<script src="{% static 'js/components/card.js' %}"></script>
<script src="{% static 'vendored/js/bootstrap.bundle.min.js' %}"></script>
<script src="{% static 'vendored/js/masonry.min.js' %}"></script>
<script src="{% static 'vendored/js/long_press.js' %}" async defer></script>
<script src="{% static 'vendored/js/jscolor.min.js' %}" async></script>
<script src="{% static 'vendored/js/color.global.min.js' %}"></script>
<script src="{% static 'vendored/js/sortable.min.js' %}"></script>
<script src="{% static 'vendored/js/jquery-sortable.js' %}"></script>
<script src="{% static 'vendored/js/altcha.min.js' %}" async defer type="module"></script>

<script type="text/javascript" src="{% static 'vendored/js/toastify.min.js' %}" async defer></script>
<script src="{% static 'js/cookies/cookie.js' %}?v=1"></script>

<script type="text/javascript" src="{% static 'js/emailmagic.js' %}?v=3" defer></script>
<script src="{% static 'js/multistepmodal.js' %}" defer></script>
<script src="{% static 'js/components/tdInputs.js' %}" defer></script>
<script src="{% static 'vendored/js/getCountryByTZ.min.js' %}"></script>

<link rel="apple-touch-icon" sizes="180x180" href="{% static 'favicons/apple-touch-icon.png' %}?v=QEJXGyWNR2">
<link rel="icon" type="image/png" sizes="32x32" href="/static/favicons/favicon-32x32.png?v=QEJXGyWNR2">
<link rel="icon" type="image/png" sizes="16x16" href="/static/favicons/favicon-16x16.png?v=QEJXGyWNR2">
<link rel="manifest" href="/static/favicons/site.webmanifest?v=QEJXGyWNR2">
<link rel="mask-icon" href="/static/favicons/safari-pinned-tab.svg?v=QEJXGyWNR2" color="#5bbad5">
<link rel="shortcut icon" href="/static/favicons/favicon.ico?v=QEJXGyWNR2">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/static/favicons/browserconfig.xml?v=QEJXGyWNR3">
<meta name="theme-color" content="#ffffff">

<meta name="twitter:card" content="summary">
{#<meta name="twitter:creator" content="@filamentcolors">#}
<meta name="twitter:site" content="@filamentcolors">

<meta name="twitter:image:width" content="760">
<meta name="twitter:image:height" content="400">
<meta name="og:image:width" content="760">
<meta name="og:image:height" content="400">

<script>
  let $deck, $msnry;

  function debounce_leading(func, timeout = 300) {
    // https://www.freecodecamp.org/news/javascript-debounce-example/
    let timer;
    return (...args) => {
      if (!timer) {
        func.apply(this, args);
      }
      clearTimeout(timer);
      timer = setTimeout(() => {
        timer = undefined;
      }, timeout);
    };
  }
  function debounce(func, wait) {
    let timeoutId = null;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, wait);
    };
  };

  function throttle(fn, wait, args = null) {
    let time = Date.now();
    return function() {
      if ((time + wait - Date.now()) < 0) {
        if (args !== null) {
          fn(...args);
        } else {
          fn();
        }
        time = Date.now();
      }
    };
  }

  function onLoadMain(evt) {
    tooltips();
    lazyloadimages();

    let loadedInTitle = $("#newTitle");
    if (loadedInTitle) {
      $("title").text(loadedInTitle.text());
    }

    $deck = $("#deck-of-many-things");
    if ($deck.length) {
      // reinit masonry if we need to
      $msnry = $deck.masonry(
        {
          "percentPosition": true,
          "itemSelector": ".swatchbox"
        });
      window.msnry = $msnry.data("masonry");
    }

    emailMagic();
  }

  htmx.onLoad(debounce_leading(onLoadMain, 30));

  function showToast(message) {
    Toastify({
      text: message,
      duration: 5000,
      backgroundColor: "#4caf50"
    }).showToast();
  }

  function showToastError(message) {
    Toastify({
      text: message,
      duration: 5000,
      backgroundColor: "#d9534f"
    }).showToast();
  }

  function hideAllPopovers() {
    $("[data-bs-toggle='popover']").popover("hide");
  }

  htmx.on("htmx:responseError", function(evt) {
    if (evt.detail.xhr.status === 701) {
      showToastError("That doesn't look like a valid color. Try again?");
    } else if (evt.detail.xhr.status === 702) {
      showToastError("Missing color code - can't work on what I can't see!");
    } else if (evt.detail.xhr.status === 703) {
      showToastError("Unprocessable LAB string; please check your input.");
    } else {
      Toastify({
        text: evt.detail.xhr.responseText + `<p>Status: ${evt.detail.xhr.status}</p>`,
        className: "text-black text-center",
        duration: 20000,
        backgroundColor: "#fff"
      }).showToast();
    }
  });

  htmx.on("htmx:afterRequest", function(evt) {
    const element = evt.detail.elt;
    if (element.id === "filterInput") {
      $deck.masonry("destroy");
    }
  });

  htmx.on("htmx:afterSwap", function(evt) {
    const element = evt.detail.elt;
    if (!$deck) {
      // on first load, we need to finish initializing everything
      // before we can use this, so abort and wait for the next one
      $deck = $("#deck-of-many-things");
      return;
    }
    if (element.classList.contains("swatchbox")) {
      // infinite scroll loading
      let newSwatches = $deck.find(".swatchbox:not([style])");
      if (newSwatches.length) {
        $deck.masonry("appended", newSwatches);
      }
    }
  });

  function lazyloadimages() {
    const images = document.querySelectorAll("img.lazy-load-image[data-src]");

    // Fallback for very old browsers: just do the minimal-change approach
    if (!("IntersectionObserver" in window)) {
      images.forEach(preloadAndSwap);
      return;
    }

    const io = new IntersectionObserver((entries, observer) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) return;
        const img = entry.target;
        observer.unobserve(img);
        preloadAndSwap(img);
      });
    }, {
      root: null,
      rootMargin: "200px 0px", // start 200px before it appears
      threshold: 0.01
    });

    images.forEach((img) => io.observe(img));

    function preloadAndSwap(img) {
      img.setAttribute("loading", "lazy");
      img.setAttribute("decoding", "async");

      const realSrc = img.getAttribute("data-src");
      if (!realSrc) return;

      const preloader = new Image();
      preloader.decoding = "async";

      preloader.addEventListener("load", async () => {
        try {
          if (preloader.decode) await preloader.decode();
        } catch (e) { /* ignore */
        }
        img.src = realSrc;
        img.removeAttribute("data-src");
        img.classList.remove("lazy-load-image");
      }, { once: true });

      preloader.addEventListener("error", () => {
        img.classList.remove("lazy-load-image");
        img.classList.add("lazy-load-error");
      }, { once: true });

      preloader.src = realSrc;
    }
  }

  function tooltips() {
    // wipe the tooltips and popovers if they're loaded so that they don't screw
    // up the new page
    if (window.popoverList) {
      window.popoverList.forEach((popover) => {
        try {
          popover.dispose();
        } catch (error) {
          // ignore errors if the popover is already disposed
        }
      });
    }
    const popoverTriggerList = [].slice.call(document.querySelectorAll("[data-bs-toggle=\"popover\"]"));
    window.popoverList = [...popoverTriggerList].map(
      popoverTriggerEl => new bootstrap.Popover(popoverTriggerEl)
    );

    if (window.tooltipList) {
      window.tooltipList.forEach((tooltip) => {
        try {
          tooltip.dispose();
        } catch (error) {
          // ignore errors if the tooltip is already disposed
        }
      });
    }
    const tooltipTriggerList = document.querySelectorAll("[data-bs-toggle=\"tooltip\"]");
    window.tooltipList = [...tooltipTriggerList].map(
      tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl)
    );
  }

  htmx.config.historyCacheSize = 10;
  htmx.config.refreshOnHistoryMiss = true;
  htmx.config.useTemplateFragments = true;
  htmx.config.globalViewTransitions = true;

  // https://stackoverflow.com/a/920322
  $.fn.exists = function() {
    return this.length !== 0;
  };

  // https://stackoverflow.com/a/8027526
  $.isHexColor = hex => {
    hex = hex.replace("#", "").trim();
    return typeof hex === "string" && (hex.length === 6 || hex.length === 3) && !isNaN(Number("0x" + hex));
  };
  $.fn.extend({
    disableSelection: function() {
      return this.each(function() {
        this.onselectstart = function() {
          return false;
        };
        this.unselectable = "on";
        $(this).css("user-select", "none");
        $(this).css("-o-user-select", "none");
        $(this).css("-moz-user-select", "none");
        $(this).css("-khtml-user-select", "none");
        $(this).css("-webkit-user-select", "none");
      });
    }
  });

  $(document).ready(function() {
    onLoadMain({});
    jscolor.presets.default = {
      format: "hex"
    };
    // do this to make bootstrap modals auto-focus.
    // delegate to body so that we only have to set it up once.
    // adapted from https://stackoverflow.com/a/48432381
    document.body.addEventListener("shown.bs.modal", (e) => {
      var ele = $(e.target).find("input[type=text],textarea,select").filter(":visible:first"); // find the first input on the bs modal
      if (ele) {
        ele.focus();
      } // if we found one, set focus.
    });
  });

  function observeElement(element, config = {
    attributes: true,
    childList: true,
    subtree: true,
    characterData: true
  }) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation type:", mutation.type);

        if (mutation.type === "attributes") {
          console.log(`Attribute "${mutation.attributeName}" changed.`);
        }

        if (mutation.type === "childList") {
          console.log("Child nodes changed:");
          mutation.addedNodes.forEach((node) => {
            console.log("Added node:", node);
          });
          mutation.removedNodes.forEach((node) => {
            console.log("Removed node:", node);
          });
        }

        if (mutation.type === "characterData") {
          console.log("Character data changed:", mutation.target.textContent);
        }
      });
    });

    observer.observe(element, config);

    return observer;
  }

</script>
